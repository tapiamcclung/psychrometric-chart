<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart 8</title>
    <style>
        body {
            font-family: "Segoe UI";
            height: 100%;
       }
        #chartdiv {
            width: 90%;
            height: calc(90vh - 30px);
            max-width: 100%;
            margin: auto;
        }
        #fileInput {
            width: 500px;
        }
    </style>
</head>
<body>
    <h1>8</h1>
    <div>
        <label>Seleccione un archivo .epw:</label>
        <input type="file" id="fileinput">
    </div>
    <div id="chartdiv"></div>

    <script src="https://cdn.amcharts.com/lib/5/index.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/xy.js"></script>
    <script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

    <script type="module">
        import {flatRollup} from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
        import {epwJson} from "../jscripts/epw2json.js"
        import * as Psychrolib from "./psychrolib.js"

        // function to create a range array
        const arrayRange = (start, stop, step) =>
            Array.from(
                { length: (stop - start) / step + 1 },
                (value, index) => parseFloat((start + index * step).toFixed(1))
            );

        //function to get psychrometric data
        const get_psychroData = altitude => {
            let dryBulb = arrayRange(0, 50, 0.1); // 0 to 50 every 0.1 oC
            let relativeHumidity = arrayRange(0.1, 1, 0.1); // 0.1 to 1 every 0.1 %

            //call this function with an altitude value
            if(altitude != 0){
                altitude = altitude;
            } else {
                altitude = 0;
            }

            //set unit system - SI
            psychrolib.SetUnitSystem(psychrolib.SI);
            //barometric pressure by altitude
            let pressure = psychrolib.GetStandardAtmPressure(altitude);

            let data = [],
                temp;

            //###################### Relative Humidity Lines #################################
            for (let [keyTemp, valueTemp] of Object.entries(dryBulb)) {
                let currentData = {temp: valueTemp};

                for (let [keyHumidity, valueHumidity] of Object.entries(relativeHumidity)) {
                    let ah = psychrolib.GetHumRatioFromRelHum(valueTemp, valueHumidity, pressure)*1000;
                    currentData[`hum${parseInt(keyHumidity)+1}`] = ah;
                }
                data.push(currentData);
            }
            //###################### Relative Humidity Lines #################################

            return data;
        }

        // function to create an axis range
        const createRange = (value, axis, label) => {
            let rangeDataItem = axis.makeDataItem({
                value: value
            });

            let range = axis.createAxisRange(rangeDataItem);

            range.get("label").setAll({
                forceHidden: false,
                text: label,
                fontSize: "0.75em"
            });

            range.get("tick").set("visible", true);
            range.get("grid").setAll({
                forceHidden: true,
                strokeOpacity: 0.2,
                location: 1
            });
        }

        // function to create RH lines series
        const createRHSeries = (name, field, lineType) => {
            let series = chart.series.push(
                am5xy.SmoothedXLineSeries.new(root, {
                    name: name,
                    xAxis: xAxis,
                    yAxis: yAxis,
                    valueYField: field,
                    valueXField: "temp",
                    baseAxis: name == "100%" ? yAxis : xAxis,
                    stroke: am5.color(0x767d84),
                    fill: am5.color(0xffffff),
                    layer: 30
                })
            );
            if (name == "100%") {
                series.strokes.template.setAll({
                    strokeWidth: 1,
                    strokeOpacity: 0.7,
                });
                series.fills.template.setAll({
                    fillOpacity: 1,
                    visible: true
                });
            } else {
                series.strokes.template.setAll({
                    strokeDasharray: [3, 2],
                    strokeWidth: 1,
                    strokeOpacity: 0.7,
                });
            }
            series.data.setAll(psychroData);
        }

        // function to create data series from epw
        const createDataSeries = (name, chartData) => {
            let series = chart.series.push(am5xy.LineSeries.new(root, {
                name: name,
                xAxis: xAxis,
                yAxis: yAxis,
                valueYField: "ah",
                valueXField: "t",
            }));
            series.strokes.template.set("visible", false);
            series.bullets.push(() => {
                var bulletCircle = am5.Circle.new(root, {
                  radius: 2,
                  fill: am5.color("#00F"),
                  fillOpacity: 0.8,
                  layer: 30
                });
                return am5.Bullet.new(root, {
                  sprite: bulletCircle
                });
              });

            series.data.setAll(chartData);
            chart.set(name, series);
        }

        // function to create heatmap data series from epw
        const createHeatSeries = (name, chartData) => {
            let heatSeries = chart.series.push(am5xy.ColumnSeries.new(root, {
                name: name,
                calculateAggregates: true,
                stroke: am5.color(0xffffff),
                fill: am5.color(0xfe131a),
                fillOpacity: 0.75,
                clustered: false,
                xAxis: xHeatAxis,
                yAxis: yHeatAxis,
                categoryXField: "t",
                categoryYField: "ah",
                valueField: "n"
            }));

            heatSeries.columns.template.setAll({
                tooltipText: "T: {t}, AH: {ah}, N: {n}",
                //tooltipText: "{n}",
                strokeOpacity: 0.5,
                strokeWidth: 2,
                fillOpacity: 0.75,
                width: am5.percent(90),
                height: am5.percent(90)
            });

            heatSeries.columns.template.events.on("pointerover", event => {
                let di = event.target.dataItem;
                if (di) {
                    heatLegend.showValue(di.get("value", 0));
                }
            });

            heatSeries.events.on("datavalidated", () => {
                heatLegend.set("startValue", heatSeries.getPrivate("valueLow"));
                heatLegend.set("endValue", heatSeries.getPrivate("valueHigh"));
                heatLegend.set("visible", true);
            });

            // Set up heat rules
            heatSeries.set("heatRules", [{
                target: heatSeries.columns.template,
                min: am5.color(0xfffb77),
                max: am5.color(0xfe131a),
                dataField: "value",
                key: "fill"
            }]);

            heatSeries.data.setAll(chartData);
            chart.set(name, heatSeries);

            let temps = arrayRange(0, 49, 1),
                absHums =  arrayRange(0, 31, 1),
                axisTemps = temps.map( t => { return {"t": t} }),
                axisHums = absHums.map( ah => { return {"ah": ah} });

            xHeatAxis.data.setAll(axisTemps);
            yHeatAxis.data.setAll(axisHums);
        }

        // function to read epw file
        const readSingleFile = file => {
            let f = file;
            if (f) {
                let r = new FileReader();
                r.onloadstart = e => {
                    document.getElementById("fileinput").innerHTML = "Parsing file...";
                };
                r.onload = e => { // lo lee como archivo
                    let contents = e.target.result,
                        raw = r.result,
                        epw = epwJson(raw); // parsea el archivo epw de json object

                        //let altitude = epw.elevation != undefined ? epw.elevation ? 0;
                        //set unit system - SI
                        psychrolib.SetUnitSystem(psychrolib.SI);
                        let altitude = 0,
                            pressure = psychrolib.GetStandardAtmPressure(altitude),

                            // convert relative humidity from epw to absolute humidity to plot in chart
                            pointData = epw.weatherData.map( d => {
                                let ah = psychrolib.GetHumRatioFromRelHum(+d[6], +d[8]/100, pressure)*1000
                                return {"t":+d[6],
                                        "tFloor": Math.floor(d[6]),
                                        "ah": ah,
                                        "ahFloor": Math.floor(ah)}
                        }),
                            // sumarize data in  groups of temperature, absolute humidity, and number of observations
                            heatData = flatRollup(pointData, d => d.length, d => d.tFloor, d => d.ahFloor)
                                .map(d => { return {"t": d[0], "ah":d[1], "n":d[2]} });

                        // clean series before adding a new one
                        if (chart.get("Hourly Data Points")) {
                            // Remove previous series
                            let currentSeries = chart.get("Hourly Data Points");
                            let data = currentSeries.data.values;
                            chart.series.removeValue(currentSeries);
                        }
                        if (chart.get("Data Grid")) {
                            // Remove previous series
                            let currentSeries = chart.get("Data Grid");
                            let data = currentSeries.data.values;
                            chart.series.removeValue(currentSeries);
                        }
                        createDataSeries("Hourly Data Points", pointData);
                        createHeatSeries("Data Grid", heatData);
                        legend.data.setAll([chart.get("Data Grid"), chart.get("Hourly Data Points")]);

                        // Update chart info
                        let chartInfoText = `${epw.stationLocation}, ${epw.country}\nElevación: ${epw.elevation} m\nLatitud: ${epw.latitude}\nLongitud: ${epw.longitude}`;
                        chartInfo.set("text", chartInfoText);
                };
                r.readAsText(f);
            } else {
                alert("Failed to load file");
            }
        };

        let psychroData = get_psychroData(0);

        // get temperature values where 40%-100% RH lines intersect with truncated axis
        let limit40 = Object.values(psychroData.filter(k => k.temp == 50)[0]).filter( v => v != 50)[3];
        let tempTicks = [5,6,7,8,9,10].map( rh => {
            let minTemp = psychroData.filter(k => k[`hum${rh}`] > limit40)[0].temp, // min of values above 40
                maxTemp = psychroData.filter(k => k[`hum${rh}`] < limit40).slice(-1)[0].temp, // max of values below 40
                limitTemp = parseFloat((minTemp + (maxTemp - minTemp)/2).toFixed(2));
            return limitTemp;
        });

        // Create root element
        let root = am5.Root.new("chartdiv");
        root._logo.dispose();

        // Set themes
        root.setThemes([
            am5themes_Animated.new(root)
        ]);

        // Create chart
        let chart = root.container.children.push(
            am5xy.XYChart.new(root, {
                panX: true,
                panY: true,
                wheelX: "panX",
                wheelY: "zoomXY",
                layout: root.verticalLayout,
                paddingLeft: 5,
                paddingRight: 5,
            })
        );

        // Create axes
        let xAxis = chart.xAxes.push(
            am5xy.ValueAxis.new(root, {
                min: 0,
                max: 50,
                strictMinMax: true,
                maxDeviation: 0,
                renderer: am5xy.AxisRendererX.new(root, {
                    minGridDistance: 100,
                    minorGridEnabled: true,
                    stroke: am5.color(0x767d84),
                    strokeOpacity: 1,
                    strokeWidth: 1
                }),
                tooltip: am5.Tooltip.new(root, {
                    themeTags: ["axis"],
                    animationDuration: 300
                })
            })
        );

        xAxis.children.push(am5.Label.new(root, {
            text: "Dry Bulb Temperature (°C)",
            textAlign: "center",
            x: am5.p50,
            fontSize: "0.75em"
        }));

        let xRenderer = xAxis.get("renderer");
        xRenderer.ticks.template.setAll({
            visible: true
        });
        xRenderer.labels.template.setAll({
            fontSize: "0.75em"
        });

        let yAxis = chart.yAxes.push(
            am5xy.ValueAxis.new(root, {
                min: 0,
                max: 32,
                strictMinMax: true,
                maxDeviation: 0,
                renderer: am5xy.AxisRendererY.new(root, {}),
                tooltip: am5.Tooltip.new(root, {
                    themeTags: ["axis"],
                    animationDuration: 300
                })
            })
        );

        let yRenderer = yAxis.get("renderer");
        yRenderer.grid.template.set("forceHidden", true);
        yRenderer.labels.template.set("forceHidden", true);

        let yAxisAH = chart.yAxes.push(
            am5xy.ValueAxis.new(root, {
                min: 0,
                max: 32,
                x: 0,
                strictMinMax: true,
                maxDeviation: 0,
                renderer: am5xy.AxisRendererY.new(root, {
                    opposite: true,
                    minGridDistance: 50,
                    stroke: am5.color(0x767d84),
                    strokeOpacity: 1,
                    strokeWidth: 1,
                    minorGridEnabled: true,
                    visible: true
                }),
            })
        );

        yAxisAH.children.push(am5.Label.new(root, {
            text: "Absolute Humidity (g/kg)",
            textAlign: "center",
            y: am5.p50,
            rotation: 90,
            fontSize: "0.75em"
        }));

        let yRendererAH = yAxisAH.get("renderer");
        yRendererAH.ticks.template.setAll({
            visible: true
        });
        yRendererAH.grid.template.set("forceHidden", false);
        yRendererAH.labels.template.setAll({
            forceHidden: false,
            fontSize: "0.75em"
        });

        let xAxisRH = chart.xAxes.push(
            am5xy.ValueAxis.new(root, {
                min: 0,
                max: 50,
                strictMinMax: true,
                maxDeviation: 0,
                numberFormat: "#.'%'",
                layer: 10,
                renderer: am5xy.AxisRendererX.new(root, {
                    opposite: true,
                    minGridDistance: 50,
                    stroke: am5.color(0x767d84),
                    strokeOpacity: 1,
                    strokeWidth: 1
                }),
            })
        );

        let xRendererRH = xAxisRH.get("renderer");
        xRendererRH.grid.template.set("forceHidden", true);
        xRendererRH.labels.template.set("forceHidden", true);

        // Place labels for RH lines on top x axis
        tempTicks.forEach( (v, i) => {
            let label = `${(i+5)*10}%`;
            createRange(v, xAxisRH, label);
        });

        let yAxisRH = chart.yAxes.push(
            am5xy.ValueAxis.new(root, {
                min: 0,
                max: 32,
                strictMinMax: true,
                maxDeviation: 0,
                numberFormat: "#.'%'",
                renderer: am5xy.AxisRendererY.new(root, {
                    opposite: true,
                    minGridDistance: 50,
                    stroke: am5.color(0x767d84),
                    strokeOpacity: 1,
                    strokeWidth: 1,
                    inside: true
                }),
            })
        );

        let yRendererRH = yAxisRH.get("renderer");
        yRendererRH.grid.template.set("forceHidden", true);
        yRendererRH.labels.template.set("forceHidden", true);

        // Get chart values for last temperature and calculate labels
        Object.values(psychroData.filter(k => k.temp == 50)[0]).filter( v => v != 50).forEach( (v, i) => {
            let label = `${(i+1)*10}%`;
            createRange(v, yAxisRH, label);
        });

        // Create relative humidity series
        let relativeHumidity = arrayRange(0.1, 1, 0.1);
        relativeHumidity.forEach( rh => {
            let name = rh.toLocaleString("en", {style: "percent"}),
                field = `hum${rh*10}`;
            createRHSeries(name, field);
        });

        // heatmap to show grid of values
        let xHeatAxis = chart.xAxes.push(
            am5xy.CategoryAxis.new(root, {
                maxDeviation: 0,
                renderer: am5xy.AxisRendererX.new(root, {
                    minGridDistance: 30
                }),
                categoryField: "t"
            })
        );
        let xHeatRenderer = xHeatAxis.get("renderer");
        xHeatRenderer.grid.template.set("visible", false);
        xHeatRenderer.labels.template.set("forceHidden", true);

        let yHeatAxis = chart.yAxes.push(
            am5xy.CategoryAxis.new(root, {
                maxDeviation: 0,
                renderer: am5xy.AxisRendererY.new(root, {
                    minGridDistance: 30,
                    minorGridEnabled: true,
                    visible: false
                }),
                categoryField: "ah"
            })
        );
        let yHeatRenderer = yHeatAxis.get("renderer");
        yHeatRenderer.grid.template.set("visible", false);
        yHeatRenderer.labels.template.set("forceHidden", true);

        //TODO: fix heatLegend tooltip font size
        //TODO: fix zoom. It either zooms out automatically or grid zooms in and background returns

        // add chart info
        let chartInfo = root.container.children.push(am5.Label.new(root, {
            text: "",
            textAlign: "left",
            fontSize: "1em",
            y: 20,
            layer: 30,
            paddingTop: 0,
            paddingBottom: 0
        }));

        // add comfort zone
        let seriesCZ = chart.series.push(am5xy.LineSeries.new(root, {
            name: "CZ",
            xAxis: xAxis,
            yAxis: yAxis,
            valueYField: "ah",
            valueXField: "t",
            stroke: am5.color(0x000),
            fill: am5.color("#35FE4C"),
            layer: 30,
            tooltipText: "{valueY}",
            showTooltipOn: "click"
        }));
        // TODO: always show tooltip when clicking CZ? Right now it only shows when clicking outside of heat map grid

        seriesCZ.strokes.template.setAll({
            strokeWidth: 3,
            strokeOpacity: 0.7,
        });
        seriesCZ.fills.template.setAll({
            fillOpacity: 0.25,
            visible: true
        });

        seriesCZ.strokes.template.set("visible", true);

        // TODO: calculate comfort zone region limits for other cities
        let czT = psychroData.filter( d => d.temp >= 20 && d.temp <= 27);

        let part80 = czT.filter(d => d.temp <= 25).map(({temp,hum8}) => ({temp, hum8})),
            part2750 = czT.filter(d => d.temp == 27).map(({temp,hum5}) => ({temp, hum5})),
            part2720 = czT.filter(d => d.temp == 27).map(({temp,hum2}) => ({temp, hum2})),
            part20 = czT.map(({temp,hum2}) => ({temp, hum2})),

            p80Data = part80.map( d => { return {t: d.temp, ah: d.hum8}}),
            p2750Data = part2750.map( d => { return {t: d.temp, ah: d.hum5}}),
            p2720Data = part2720.map( d => { return {t: d.temp, ah: d.hum2}}),
            p20Data = part20.map( d => { return {t: d.temp, ah: d.hum2}}),

            czData = [p20Data[0]].concat(p80Data).concat(p2750Data).concat(p2720Data).concat(p20Data.reverse());

        let tooltip = am5.Tooltip.new(root, {
            getFillFromSprite: false,
            getStrokeFromSprite: false,
            dy: 200,
            dx: 250
        });

        tooltip.get("background").setAll({
            fill: am5.color(0xffffff),
            fillOpacity: 0.8,
            stroke: am5.color(0x000000),
            strokeOpacity: 0.8
        });

        seriesCZ.set("tooltip", tooltip);
        seriesCZ.fills.template.setAll({
            tooltipHTML: "",
            tooltipText: "{name}",
            showTooltipOn: "click"
        });

        seriesCZ.fills.template.events.on("click", function(ev) {
            let cz = ev.target;
            cz.set("tooltipHTML","<img src=\"../gifs/10.gif\" width=\"500\">");
        });

        // CZ label
        let label = seriesCZ.children.push(am5.Label.new(root, {
            text: "ZONA DE CONFORT",
            fontSize: "0.9em",
            fontWeight: "600",
            opacity: 0.9,
            x: am5.percent(51.5),
            y: am5.percent(76),
            centerX: am5.p100,
            centerY: am5.p100,
            layer: 30
        }));

        seriesCZ.data.setAll(czData);
        chart.set("CZ", seriesCZ);

        // Grid and points legend
        let legend = chart.bottomAxesContainer.children.push(am5.Legend.new(root, {
            layout: root.horizontalLayout,
            y: am5.percent(50),
            centerY: am5.percent(50)
        }));

        legend.labels.template.set("fontSize", "0.75em");
        legend.markers.template.setAll({
            width: 24,
            height: 18
        });
        legend.markerRectangles.template.setAll({
            cornerRadiusTL: 0,
            cornerRadiusTR: 0,
            cornerRadiusBL: 0,
            cornerRadiusBR: 0,
            opacity: 0.75
        });

        // Heat legend
        let heatLegend = chart.bottomAxesContainer.children.push(am5.HeatLegend.new(root, {
            orientation: "horizontal",
            endColor: am5.color(0xfe131a),
            startColor: am5.color(0xfffb77),
            width: am5.p50,
            visible: false
        }));
        heatLegend.startLabel.set("fontSize", "0.75em");
        heatLegend.endLabel.set("fontSize", "0.75em");

        // General legend container
        let legendContainer = chart.children.push(am5.Container.new(root, {
            centerX: am5.p50,
            x: am5.p50,
            layout: root.gridLayout
        }));

        // Add both legends
        legendContainer.children.push(legend);
        legendContainer.children.push(heatLegend);

        // Read file and draw chart
        let fileInput = document.getElementById("fileinput"); //obtiene el archivo
        fileInput.onchange = evt => {
            readSingleFile(evt.target.files[0]);
        };
        // TODO: enable drag and drop file

    </script>

</body>
</html>